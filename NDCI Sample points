// 1) Date and AOI variables (so they can be easily redefined later on)
var START = ee.Date('2025-03-01');   // start is inclusive
var END   = ee.Date('2025-10-01');   // end is exclusive
var AOI = southaustralia;   

// // Check AOI
// Map.centerObject(AOI, 11);
// Map.addLayer(AOI, {color:'yellow'}, 'South Australia');

// 2) Define parameters for s2 image acquisition (dates, geometry, cloud %)
var s2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
.filterDate(START, END)
.filterBounds(AOI)
.filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE' , 5))

// // How many images made it through your filters?
print('S2 images kept:', s2.size());


// // 3) Make the collection homogeneous by selecting a consistent band set
// //    This keeps all spectral bands B*, plus AOT, WVP, and SCL (no QA*/MSK_CLASSI*).
// function keepConsistentBands(img) {
//   return img
//     .select(['B.*', 'AOT', 'WVP', 'SCL'])  // regex 'B.*' grabs B1..B12, B8A
//     .toFloat()                               // (optional) ensure consistent type
//     .copyProperties(img, img.propertyNames());
// }

// 4) Mask clouds, snow, ice
function maskSCL(img) {
  var scl = img.select('SCL');
  var good = scl.eq(6) // water
    .and(scl.neq(3))   // cloud shadow
    .and(scl.neq(8))      // cloud
    .and(scl.neq(9))      // high-prob cloud (if present)
    .and(scl.neq(10))     // cirrus
    .and(scl.neq(11));    // snow/ice
  return img.updateMask(good);
}

// // 5) Keep only the bands needed to compute NDCI and compute NDCI immediately
function toNDCI(img){
  // Select only NIR & RED + SCL for masking (small memory footprint)
  img = img.select(['B4','B5','SCL']).float();
  img = maskSCL(img);
  var NDCI = img.normalizedDifference(['B5','B4']).rename('NDCI');
  return NDCI.copyProperties(img, img.propertyNames()); // single-band image
}

// // 6) Define new s2 dataset
var s2NDCI = s2.map(toNDCI);  // Collection of 1-band NDCI images
var ndciMax = s2NDCI.max().clip(AOI);       // per-pixel max across the period

// (Optional) Mask a strip near the coastline to reduce land–water adjacency effects
//    Uses ESA WorldCover to define 'land' and drops pixels within 500 m of land
var worldcover = ee.Image('ESA/WorldCover/v200/2021'); // class 80 = water
var waterMask = worldcover.select('Map').eq(80);           // 
// var distToLand = land.selfMask().distance(ee.Kernel.euclidean(1, 'meters')); // meters
// var offshore500m = distToLand.gte(500);
var ndciWater = ndciMax.updateMask(waterMask);

// (Optional) require a minimum number of clear observations to avoid 1-off spikes
var validCount = s2NDCI.map(function(img){ return img.mask().rename('valid'); }).sum();
var ndciWater_valid = ndciWater.updateMask(validCount.gte(3));  // need ≥3 valid obs

// 7) Visualize
Map.centerObject(AOI, 7);
// Map.addLayer(ndciMax,       {min:-1, max:1}, 'Max NDCI (period)');
// Robust min/max from AOI (ignore outliers)
var ndciViz = {
  min: 0,
  max: 0.20,
  palette: [
    '2c7bb6','00a6ca','00ccbc','90eb9d','ffff8c','f9d057','f29e2e','e76818','d7191c'
  ] // blue→yellow→orange→red
};

Map.addLayer(ndciWater_valid, ndciViz, 'Max NDCI over water');
Map.addLayer(ndciWater, ndciViz, 'MaxNDCI without validity filter')
